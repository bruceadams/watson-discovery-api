/* 
 * Discovery
 *
 * The IBM Watson&trade; Discovery Service is a cognitive search and content analytics engine that you can add to applications to identify patterns, trends and actionable insights to drive better decision-making. Securely unify structured and unstructured data with pre-enriched content, and use a simplified query language to eliminate the need for manual filtering of results.
 *
 * OpenAPI spec version: 1.0
 * 
 * Generated by: https://openapi-generator.tech
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct DocumentCounts {
  /// The total number of available documents in the collection.
  #[serde(rename = "available")]
  available: Option<i64>,
  /// The number of documents in the collection that are currently being processed.
  #[serde(rename = "processing")]
  processing: Option<i64>,
  /// The number of documents in the collection that failed to be ingested.
  #[serde(rename = "failed")]
  failed: Option<i64>,
  /// The number of documents that have been uploaded to the collection, but have not yet started processing.
  #[serde(rename = "pending")]
  pending: Option<i64>
}

impl DocumentCounts {
  pub fn new() -> DocumentCounts {
    DocumentCounts {
      available: None,
      processing: None,
      failed: None,
      pending: None
    }
  }

  pub fn set_available(&mut self, available: i64) {
    self.available = Some(available);
  }

  pub fn with_available(mut self, available: i64) -> DocumentCounts {
    self.available = Some(available);
    self
  }

  pub fn available(&self) -> Option<&i64> {
    self.available.as_ref()
  }

  pub fn reset_available(&mut self) {
    self.available = None;
  }

  pub fn set_processing(&mut self, processing: i64) {
    self.processing = Some(processing);
  }

  pub fn with_processing(mut self, processing: i64) -> DocumentCounts {
    self.processing = Some(processing);
    self
  }

  pub fn processing(&self) -> Option<&i64> {
    self.processing.as_ref()
  }

  pub fn reset_processing(&mut self) {
    self.processing = None;
  }

  pub fn set_failed(&mut self, failed: i64) {
    self.failed = Some(failed);
  }

  pub fn with_failed(mut self, failed: i64) -> DocumentCounts {
    self.failed = Some(failed);
    self
  }

  pub fn failed(&self) -> Option<&i64> {
    self.failed.as_ref()
  }

  pub fn reset_failed(&mut self) {
    self.failed = None;
  }

  pub fn set_pending(&mut self, pending: i64) {
    self.pending = Some(pending);
  }

  pub fn with_pending(mut self, pending: i64) -> DocumentCounts {
    self.pending = Some(pending);
    self
  }

  pub fn pending(&self) -> Option<&i64> {
    self.pending.as_ref()
  }

  pub fn reset_pending(&mut self) {
    self.pending = None;
  }

}



