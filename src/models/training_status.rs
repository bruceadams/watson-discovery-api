/* 
 * Discovery
 *
 * The IBM Watson&trade; Discovery Service is a cognitive search and content analytics engine that you can add to applications to identify patterns, trends and actionable insights to drive better decision-making. Securely unify structured and unstructured data with pre-enriched content, and use a simplified query language to eliminate the need for manual filtering of results.
 *
 * OpenAPI spec version: 1.0
 * 
 * Generated by: https://openapi-generator.tech
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct TrainingStatus {
  #[serde(rename = "total_examples")]
  total_examples: Option<i32>,
  #[serde(rename = "available")]
  available: Option<bool>,
  #[serde(rename = "processing")]
  processing: Option<bool>,
  #[serde(rename = "minimum_queries_added")]
  minimum_queries_added: Option<bool>,
  #[serde(rename = "minimum_examples_added")]
  minimum_examples_added: Option<bool>,
  #[serde(rename = "sufficient_label_diversity")]
  sufficient_label_diversity: Option<bool>,
  #[serde(rename = "notices")]
  notices: Option<i32>,
  #[serde(rename = "successfully_trained")]
  successfully_trained: Option<String>,
  #[serde(rename = "data_updated")]
  data_updated: Option<String>
}

impl TrainingStatus {
  pub fn new() -> TrainingStatus {
    TrainingStatus {
      total_examples: None,
      available: None,
      processing: None,
      minimum_queries_added: None,
      minimum_examples_added: None,
      sufficient_label_diversity: None,
      notices: None,
      successfully_trained: None,
      data_updated: None
    }
  }

  pub fn set_total_examples(&mut self, total_examples: i32) {
    self.total_examples = Some(total_examples);
  }

  pub fn with_total_examples(mut self, total_examples: i32) -> TrainingStatus {
    self.total_examples = Some(total_examples);
    self
  }

  pub fn total_examples(&self) -> Option<&i32> {
    self.total_examples.as_ref()
  }

  pub fn reset_total_examples(&mut self) {
    self.total_examples = None;
  }

  pub fn set_available(&mut self, available: bool) {
    self.available = Some(available);
  }

  pub fn with_available(mut self, available: bool) -> TrainingStatus {
    self.available = Some(available);
    self
  }

  pub fn available(&self) -> Option<&bool> {
    self.available.as_ref()
  }

  pub fn reset_available(&mut self) {
    self.available = None;
  }

  pub fn set_processing(&mut self, processing: bool) {
    self.processing = Some(processing);
  }

  pub fn with_processing(mut self, processing: bool) -> TrainingStatus {
    self.processing = Some(processing);
    self
  }

  pub fn processing(&self) -> Option<&bool> {
    self.processing.as_ref()
  }

  pub fn reset_processing(&mut self) {
    self.processing = None;
  }

  pub fn set_minimum_queries_added(&mut self, minimum_queries_added: bool) {
    self.minimum_queries_added = Some(minimum_queries_added);
  }

  pub fn with_minimum_queries_added(mut self, minimum_queries_added: bool) -> TrainingStatus {
    self.minimum_queries_added = Some(minimum_queries_added);
    self
  }

  pub fn minimum_queries_added(&self) -> Option<&bool> {
    self.minimum_queries_added.as_ref()
  }

  pub fn reset_minimum_queries_added(&mut self) {
    self.minimum_queries_added = None;
  }

  pub fn set_minimum_examples_added(&mut self, minimum_examples_added: bool) {
    self.minimum_examples_added = Some(minimum_examples_added);
  }

  pub fn with_minimum_examples_added(mut self, minimum_examples_added: bool) -> TrainingStatus {
    self.minimum_examples_added = Some(minimum_examples_added);
    self
  }

  pub fn minimum_examples_added(&self) -> Option<&bool> {
    self.minimum_examples_added.as_ref()
  }

  pub fn reset_minimum_examples_added(&mut self) {
    self.minimum_examples_added = None;
  }

  pub fn set_sufficient_label_diversity(&mut self, sufficient_label_diversity: bool) {
    self.sufficient_label_diversity = Some(sufficient_label_diversity);
  }

  pub fn with_sufficient_label_diversity(mut self, sufficient_label_diversity: bool) -> TrainingStatus {
    self.sufficient_label_diversity = Some(sufficient_label_diversity);
    self
  }

  pub fn sufficient_label_diversity(&self) -> Option<&bool> {
    self.sufficient_label_diversity.as_ref()
  }

  pub fn reset_sufficient_label_diversity(&mut self) {
    self.sufficient_label_diversity = None;
  }

  pub fn set_notices(&mut self, notices: i32) {
    self.notices = Some(notices);
  }

  pub fn with_notices(mut self, notices: i32) -> TrainingStatus {
    self.notices = Some(notices);
    self
  }

  pub fn notices(&self) -> Option<&i32> {
    self.notices.as_ref()
  }

  pub fn reset_notices(&mut self) {
    self.notices = None;
  }

  pub fn set_successfully_trained(&mut self, successfully_trained: String) {
    self.successfully_trained = Some(successfully_trained);
  }

  pub fn with_successfully_trained(mut self, successfully_trained: String) -> TrainingStatus {
    self.successfully_trained = Some(successfully_trained);
    self
  }

  pub fn successfully_trained(&self) -> Option<&String> {
    self.successfully_trained.as_ref()
  }

  pub fn reset_successfully_trained(&mut self) {
    self.successfully_trained = None;
  }

  pub fn set_data_updated(&mut self, data_updated: String) {
    self.data_updated = Some(data_updated);
  }

  pub fn with_data_updated(mut self, data_updated: String) -> TrainingStatus {
    self.data_updated = Some(data_updated);
    self
  }

  pub fn data_updated(&self) -> Option<&String> {
    self.data_updated.as_ref()
  }

  pub fn reset_data_updated(&mut self) {
    self.data_updated = None;
  }

}



