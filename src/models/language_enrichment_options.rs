/* 
 * Discovery
 *
 * The IBM Watson&trade; Discovery Service is a cognitive search and content analytics engine that you can add to applications to identify patterns, trends and actionable insights to drive better decision-making. Securely unify structured and unstructured data with pre-enriched content, and use a simplified query language to eliminate the need for manual filtering of results.
 *
 * OpenAPI spec version: 1.0
 * 
 * Generated by: https://openapi-generator.tech
 */

/// LanguageEnrichmentOptions : *Deprecated* Options specific to the `alchemy_language` enrichment.

#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct LanguageEnrichmentOptions {
  /// A comma-separated list of analyses that will be applied when using the `alchemy_language` enrichment. See the service documentation for details on each extract option.  Possible values include:    * entity   * keyword   * taxonomy   * concept   * relation   * doc-sentiment   * doc-emotion   * typed-rels
  #[serde(rename = "extract")]
  extract: Option<Vec<String>>,
  #[serde(rename = "sentiment")]
  sentiment: Option<bool>,
  #[serde(rename = "quotations")]
  quotations: Option<bool>,
  #[serde(rename = "showSourceText")]
  show_source_text: Option<bool>,
  #[serde(rename = "hierarchicalTypedRelations")]
  hierarchical_typed_relations: Option<bool>,
  /// Required when using the `typed-rel` extract option. Should be set to the ID of a previously published custom Watson Knowledge Studio model.
  #[serde(rename = "model")]
  model: Option<String>,
  /// If provided, then do not attempt to detect the language of the input document. Instead, assume the language is the one specified in this field.  You can set this property to work around `unsupported-text-language` errors.  Supported languages include English, German, French, Italian, Portuguese, Russian, Spanish and Swedish. Supported language codes are the ISO-639-1, ISO-639-2, ISO-639-3, and the plain english name of the language (for example \"russian\").
  #[serde(rename = "language")]
  language: Option<String>
}

impl LanguageEnrichmentOptions {
  /// *Deprecated* Options specific to the `alchemy_language` enrichment.
  pub fn new() -> LanguageEnrichmentOptions {
    LanguageEnrichmentOptions {
      extract: None,
      sentiment: None,
      quotations: None,
      show_source_text: None,
      hierarchical_typed_relations: None,
      model: None,
      language: None
    }
  }

  pub fn set_extract(&mut self, extract: Vec<String>) {
    self.extract = Some(extract);
  }

  pub fn with_extract(mut self, extract: Vec<String>) -> LanguageEnrichmentOptions {
    self.extract = Some(extract);
    self
  }

  pub fn extract(&self) -> Option<&Vec<String>> {
    self.extract.as_ref()
  }

  pub fn reset_extract(&mut self) {
    self.extract = None;
  }

  pub fn set_sentiment(&mut self, sentiment: bool) {
    self.sentiment = Some(sentiment);
  }

  pub fn with_sentiment(mut self, sentiment: bool) -> LanguageEnrichmentOptions {
    self.sentiment = Some(sentiment);
    self
  }

  pub fn sentiment(&self) -> Option<&bool> {
    self.sentiment.as_ref()
  }

  pub fn reset_sentiment(&mut self) {
    self.sentiment = None;
  }

  pub fn set_quotations(&mut self, quotations: bool) {
    self.quotations = Some(quotations);
  }

  pub fn with_quotations(mut self, quotations: bool) -> LanguageEnrichmentOptions {
    self.quotations = Some(quotations);
    self
  }

  pub fn quotations(&self) -> Option<&bool> {
    self.quotations.as_ref()
  }

  pub fn reset_quotations(&mut self) {
    self.quotations = None;
  }

  pub fn set_show_source_text(&mut self, show_source_text: bool) {
    self.show_source_text = Some(show_source_text);
  }

  pub fn with_show_source_text(mut self, show_source_text: bool) -> LanguageEnrichmentOptions {
    self.show_source_text = Some(show_source_text);
    self
  }

  pub fn show_source_text(&self) -> Option<&bool> {
    self.show_source_text.as_ref()
  }

  pub fn reset_show_source_text(&mut self) {
    self.show_source_text = None;
  }

  pub fn set_hierarchical_typed_relations(&mut self, hierarchical_typed_relations: bool) {
    self.hierarchical_typed_relations = Some(hierarchical_typed_relations);
  }

  pub fn with_hierarchical_typed_relations(mut self, hierarchical_typed_relations: bool) -> LanguageEnrichmentOptions {
    self.hierarchical_typed_relations = Some(hierarchical_typed_relations);
    self
  }

  pub fn hierarchical_typed_relations(&self) -> Option<&bool> {
    self.hierarchical_typed_relations.as_ref()
  }

  pub fn reset_hierarchical_typed_relations(&mut self) {
    self.hierarchical_typed_relations = None;
  }

  pub fn set_model(&mut self, model: String) {
    self.model = Some(model);
  }

  pub fn with_model(mut self, model: String) -> LanguageEnrichmentOptions {
    self.model = Some(model);
    self
  }

  pub fn model(&self) -> Option<&String> {
    self.model.as_ref()
  }

  pub fn reset_model(&mut self) {
    self.model = None;
  }

  pub fn set_language(&mut self, language: String) {
    self.language = Some(language);
  }

  pub fn with_language(mut self, language: String) -> LanguageEnrichmentOptions {
    self.language = Some(language);
    self
  }

  pub fn language(&self) -> Option<&String> {
    self.language.as_ref()
  }

  pub fn reset_language(&mut self) {
    self.language = None;
  }

}



