/* 
 * Discovery
 *
 * The IBM Watson&trade; Discovery Service is a cognitive search and content analytics engine that you can add to applications to identify patterns, trends and actionable insights to drive better decision-making. Securely unify structured and unstructured data with pre-enriched content, and use a simplified query language to eliminate the need for manual filtering of results.
 *
 * OpenAPI spec version: 1.0
 * 
 * Generated by: https://openapi-generator.tech
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct Enrichment {
  /// Describes what the enrichment step does.
  #[serde(rename = "description")]
  description: Option<String>,
  /// Field where enrichments will be stored. This field must already exist or be at most 1 level deeper than an existing field. For example, if `text` is a top-level field with no sub-fields, `text.foo` is a valid destination but `text.foo.bar` is not.
  #[serde(rename = "destination_field")]
  destination_field: String,
  /// Field to be enriched.
  #[serde(rename = "source_field")]
  source_field: String,
  /// Indicates that the enrichments will overwrite the destination_field field if it already exists.
  #[serde(rename = "overwrite")]
  overwrite: Option<bool>,
  /// Name of the enrichment service to call. Current options are `natural_language_understanding` and `elements`.   When using `natual_language_understanding`, the **options** object must contain Natural Language Understanding options.   When using `elements` the **options** object must contain Element Classification options. Additionally, when using the `elements` enrichment the configuration specified and files ingested must meet all the criteria specified in [the documentation](https://console.bluemix.net/docs/services/discovery/element-classification.html)     Previous API versions also supported `alchemy_language`.
  #[serde(rename = "enrichment")]
  enrichment: String,
  /// If true, then most errors generated during the enrichment process will be treated as warnings and will not cause the document to fail processing.
  #[serde(rename = "ignore_downstream_errors")]
  ignore_downstream_errors: Option<bool>,
  #[serde(rename = "options")]
  options: Option<::models::EnrichmentOptions>
}

impl Enrichment {
  pub fn new(destination_field: String, source_field: String, enrichment: String) -> Enrichment {
    Enrichment {
      description: None,
      destination_field: destination_field,
      source_field: source_field,
      overwrite: None,
      enrichment: enrichment,
      ignore_downstream_errors: None,
      options: None
    }
  }

  pub fn set_description(&mut self, description: String) {
    self.description = Some(description);
  }

  pub fn with_description(mut self, description: String) -> Enrichment {
    self.description = Some(description);
    self
  }

  pub fn description(&self) -> Option<&String> {
    self.description.as_ref()
  }

  pub fn reset_description(&mut self) {
    self.description = None;
  }

  pub fn set_destination_field(&mut self, destination_field: String) {
    self.destination_field = destination_field;
  }

  pub fn with_destination_field(mut self, destination_field: String) -> Enrichment {
    self.destination_field = destination_field;
    self
  }

  pub fn destination_field(&self) -> &String {
    &self.destination_field
  }


  pub fn set_source_field(&mut self, source_field: String) {
    self.source_field = source_field;
  }

  pub fn with_source_field(mut self, source_field: String) -> Enrichment {
    self.source_field = source_field;
    self
  }

  pub fn source_field(&self) -> &String {
    &self.source_field
  }


  pub fn set_overwrite(&mut self, overwrite: bool) {
    self.overwrite = Some(overwrite);
  }

  pub fn with_overwrite(mut self, overwrite: bool) -> Enrichment {
    self.overwrite = Some(overwrite);
    self
  }

  pub fn overwrite(&self) -> Option<&bool> {
    self.overwrite.as_ref()
  }

  pub fn reset_overwrite(&mut self) {
    self.overwrite = None;
  }

  pub fn set_enrichment(&mut self, enrichment: String) {
    self.enrichment = enrichment;
  }

  pub fn with_enrichment(mut self, enrichment: String) -> Enrichment {
    self.enrichment = enrichment;
    self
  }

  pub fn enrichment(&self) -> &String {
    &self.enrichment
  }


  pub fn set_ignore_downstream_errors(&mut self, ignore_downstream_errors: bool) {
    self.ignore_downstream_errors = Some(ignore_downstream_errors);
  }

  pub fn with_ignore_downstream_errors(mut self, ignore_downstream_errors: bool) -> Enrichment {
    self.ignore_downstream_errors = Some(ignore_downstream_errors);
    self
  }

  pub fn ignore_downstream_errors(&self) -> Option<&bool> {
    self.ignore_downstream_errors.as_ref()
  }

  pub fn reset_ignore_downstream_errors(&mut self) {
    self.ignore_downstream_errors = None;
  }

  pub fn set_options(&mut self, options: ::models::EnrichmentOptions) {
    self.options = Some(options);
  }

  pub fn with_options(mut self, options: ::models::EnrichmentOptions) -> Enrichment {
    self.options = Some(options);
    self
  }

  pub fn options(&self) -> Option<&::models::EnrichmentOptions> {
    self.options.as_ref()
  }

  pub fn reset_options(&mut self) {
    self.options = None;
  }

}



